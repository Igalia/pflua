module(..., package.seeall)

local ffi = require("ffi")
local bit = require("bit")
local C = ffi.C

local dasm = require("dasm")

local sel = require("pf.selection")
local ra  = require("pf.regalloc")

|.arch x64
|.actionlist actions

-- Table keeping machine code alive to the GC.
local anchor = {}

local debug = false

local function compile_cjmp(Dst, op, target)
   if (target == "true-label") then
      target = 0
   else
      target = target + 3
   end

   if op == "=" then
      | je   =>(target)
   elseif op == "!=" then
      | jne  =>(target)
   elseif op == ">=" then
      | jge  =>(target)
   elseif op == "<=" then
      | jle  =>(target)
   elseif op == ">" then
      | jg   =>(target)
   elseif op == "<" then
      | jl   =>(target)
   end
end

local function compile(instructions, alloc, dump)
   local Dst = dasm.new(actions)

   -- number of =>(...) style labels
   -- reserve three labels 0-2 for return cases
   local maxpc = 3

   -- allocate space for all spilled vars
   --local spilled_space = alloc.num_spilled * 32
   --if spilled_space > 0 then
   --   | sub rsp, spilled_space
   --end

   -- first go find the max number of labels
   for _, instr in ipairs(instructions) do
      if instr[1] == "label" then
         -- offset for reserved labels
         local lnum = instr[2] + 3

         if lnum + 1 > maxpc then
            maxpc = lnum + 1
            Dst:growpc(maxpc)
         end
      end
   end

   for idx, instr in ipairs(instructions) do
      local itype = instr[1]

      if itype == "label" then
         local lnum = instr[2] + 3
         |=>(lnum):

      elseif itype == "cjmp" then
         compile_cjmp(Dst, instr[2], instr[3])

      elseif itype == "jmp" then
         | jmp =>(instr[2] + 3)

      elseif itype == "cmp" then
         -- the lhs should never be an immediate so this should be non-nil
         local lhs_reg = assert(alloc[instr[2]])
         local rhs = instr[3]

         if type(rhs) == "number" then
            | cmp Rq(lhs_reg), rhs
         else
            local rhs_reg = alloc[rhs]
            | cmp Rq(lhs_reg), Rq(rhs_reg)
         end

      elseif itype == "load" then
         local target = alloc[instr[2]]
         local offset = instr[3]
         local bytes  = instr[4]

         if type(offset) == "number" then
            if bytes == 1 then
               | movzx Rq(target), byte [rdi + offset]
            elseif bytes == 2 then
               | movzx Rq(target), word [rdi + offset]
            else
               | mov   Rd(target), dword [rdi + offset]
            end
         else
            local reg = alloc[offset]

            if bytes == 1 then
               | movzx Rq(target), byte [rdi + Rq(reg)]
            elseif bytes == 2 then
               | movzx Rq(target), word [rdi + Rq(reg)]
            else
               | mov   Rd(target), dword [rdi + Rq(reg)]
            end
         end

      elseif itype == "mov" then
         local dst = alloc[instr[2]]

         if type(instr[3]) == "number" then
            | mov Rq(dst), instr[3]
         else
            | mov Rq(dst), Rq(alloc[instr[3]])
         end

      elseif itype == "mov64" then
         local dst = alloc[instr[2]]
         local imm = instr[3]
         | mov64 Rq(dst), imm

      elseif itype == "add" then
         local reg1, reg2 = alloc[instr[2]], alloc[instr[3]]
         | add Rq(reg1), Rq(reg2)

      elseif itype == "mul" then
         local reg1, reg2 = alloc[instr[2]], alloc[instr[3]]
         | imul Rq(reg1), Rq(reg2)

      elseif itype == "and" then
         local reg1, reg2 = alloc[instr[2]], alloc[instr[3]]
         | and Rq(reg1), Rq(reg2)

      elseif itype == "shl" then
         local reg1, reg2 = alloc[instr[2]], alloc[instr[3]]
         -- TODO: we want to emit shlx here but dynasm doesn't
         --       support it, so error for now
         --| shlx Rq(reg1), Rq(reg1), Rq(reg2)
         error("Unsupported instruction shlx")

      elseif itype == "add-i" then
         local reg = alloc[instr[2]]
         | add Rq(reg), instr[3]

      elseif itype == "mul-i" then
         local r = alloc[instr[2]]
         local const = instr[3]

         if const == 2 then
            | lea Rq(r), [Rq(r)*2]
         elseif const == 4 then
            | lea Rq(r), [Rq(r)*4]
         elseif const == 8 then
            | lea Rq(r), [Rq(r)*8]
         elseif const == 3 then
            | lea Rq(r), [Rq(r)+Rq(r)*2]
         elseif const == 5 then
            | lea Rq(r), [Rq(r)+Rq(r)*4]
         elseif const == 7 then
            | lea Rq(r), [Rq(r)+Rq(r)*8]
         else
            | imul Rq(r), const
         end

      elseif itype == "and-i" then
         local reg = alloc[instr[2]]
         assert(type(reg) == "number")
         assert(type(instr[3]) == "number")
         | and Rq(reg), instr[3]

      elseif itype == "shl-i" then
         local reg = alloc[instr[2]]
         | shl Rq(reg), instr[3]

      elseif itype == "add-3" then
         -- expr2 must always a register
         local reg1 = assert(alloc[instr[2]])

         -- with optimization on, the first branch doesn't happen but
         -- it can happen with the -O0 flag
         -- TODO: maybe the first branch should be classified differently
         --       at instruction selection time
         if type(instr[3]) == "number" and type(instr[4] == "number") then
            | add Rq(reg1), (instr[3] + instr[4])
         elseif type(instr[3]) == "number" then
            local reg2 = alloc[instr[4]]
            | lea Rq(reg1), [Rq(reg2)+instr[3]]
         elseif type(instr[4]) == "number" then
            local reg2 = alloc[instr[3]]
            | lea Rq(reg1), [Rq(reg2)+instr[4]]
         else
            local reg2, reg3 = alloc[instr[3]], alloc[instr[4]]
            | lea Rq(reg1), [Rq(reg2)+Rq(reg3)]
         end

      elseif itype == "ntohs" then
         local reg = alloc[instr[2]]
         | ror Rw(reg), 8
         | movzx Rq(reg), Rw(reg)

      elseif itype == "uint32" then
         local reg = alloc[instr[2]]
         | mov Rd(reg), Rd(reg)

      elseif itype == "ret-true" then
         | jmp =>(0)

      elseif itype == "ret-false" then
         | nop
         | jmp =>(1)
         -- there tend to be a lot of duplicated
         --   { "return", { "false" } }
         -- forms so optimize them out here by peeking to
         -- find repeats only separated by a label and only
         -- generate the last one
         --local next_instr = instructions[idx + 1]
         --local next_next_instr = instructions[idx + 2]
         --if next_instr and next_instr[1] == "label" and
         --   next_next_instr and next_next_instr[1] == "ret-false" then
         --   -- TODO: if we don't insert nops, bad things happen.
         --   --       so the right place to do this optimization is
         --   --       in an earlier phase of compilation...
         --   | nop
         --else
         --   | jmp =>(1)
         --end

      elseif itype == "noop" then
         -- don't output anything

      else
	 error(string.format("NYI instruction %s", itype))
      end
   end

   -- return true, false
   -- TODO: do this more cleverly
   |=>(0):
   | mov al, 0x1
   | jmp =>(2)
   |=>(1):
   | mov al, 0x0
   |=>(2):

   -- fix stack
   --if spilled_space > 0 then
   --   | add rsp, spilled_space
   --end
   | ret

   local mcode, size = Dst:build()
   local dumpstr = ""
   table.insert(anchor, mcode)

   if dump or debug then
      dasm.dump(mcode, size, function(str) dumpstr = dumpstr..str end)
   end

   if debug then
      print("mcode dump:")
      io.write(dumpstr)
   elseif dump then
      return dumpstr
   end

   return ffi.cast(ffi.typeof("bool(*)(unsigned char*, uint16_t)"),
                   mcode)
end

function load(ssa, dump)
   local ir = sel.select(ssa)
   local alloc = ra.allocate(ir)
   local fun = compile(ir, alloc, dump)

   return fun
end

function selftest()
   local sel = require("pf.selection")
   local ra = require("pf.regalloc")

   -- `ip`
   local example_1 =
      { start = "L1",
	order = { "L1", "L4", "L5" },
	blocks =
	   { L1 = { label = "L1",
		    bindings = {},
		    control = { "if", { ">=", "len", 14 }, "L4", "L5" } },
	     L4 = { label = "L4",
		    bindings = {},
		    control = { "return", { "=", { "[]", 12, 2 }, 8 } } },
	     L5 = { label = "L5",
		    bindings = {},
		    control = { "return", { "false" } } } } }

   -- `arp`
   local example_2 =
      { start = "L1",
	order = { "L1", "L4", "L5" },
	blocks =
	   { L1 = { label = "L1",
		    bindings = {},
		    control = { "if", { ">=", "len", 14 }, "L4", "L5" } },
	     L4 = { label = "L4",
		    bindings = {},
		    control = { "return", { "=", { "[]", 12, 2 }, 1544 } } },
	     L5 = { label = "L5",
		    bindings = {},
		    control = { "return", { "false" } } } } }

   -- `tcp`
   local example_3 =
      { start = "L1",
	order = { "L1", "L4", "L6", "L7", "L8", "L10", "L12", "L13",
		  "L14", "L16", "L17", "L15", "L11", "L9", "L5" },
	blocks =
	   { L1 = { label = "L1",
	            bindings = {},
	            control = { "if", { ">=", "len", 34 }, "L4", "L5" } },
	     L4 = { label = "L4",
	            bindings = { { name = "v1", value = { "[]", 12, 2 } } },
	            control = { "if", { "=", "v1", 8 }, "L6", "L7" } },
	     L6 = { label = "L6",
	            bindings = {},
	            control = { "return", { "=", { "[]", 23, 1 }, 6 } } },
	     L7 = { label = "L7",
	            bindings = {},
	            control = { "if", { ">=", "len", 54 }, "L8", "L9" } },
	     L8 = { label = "L8",
	            bindings = {},
	            control = { "if", { "=", "v1", 56710 }, "L10", "L11" } },
	     L10 = { label = "L10",
	             bindings = { { name = "v2", value = { "[]", 20, 1 } } },
	             control = { "if", { "=", "v2", 6 }, "L12", "L13" } },
	     L12 = { label = "L12",
	             bindings = {},
	             control = { "return", { "true" } } },
	     L13 = { label = "L13",
	             bindings = {},
	             control = { "if", { ">=", "len", 55 }, "L14", "L15" } },
	     L14 = { label = "L14",
	             bindings = {},
	             control = { "if", { "=", "v2", 44 }, "L16", "L17" } },
	     L16 = { label = "L16",
	             bindings = {},
	             control = { "return", { "=", { "[]", 54, 1 }, 6 } } },
	     L17 = { label = "L17",
	             bindings = {},
	             control = { "return", { "false" } } },
	     L15 = { label = "L15",
	             bindings = {},
	             control = { "return", { "false" } } },
	     L11 = { label = "L11",
	             bindings = {},
	             control = { "return", { "false" } } },
	     L9 = { label = "L9",
	            bindings = {},
	            control = { "return", { "false" } } },
	     L5 = { label = "L5",
	            bindings = {},
	            control = { "return", { "false" } } } } }

   -- `ip[1] + ip[2] + ip[3] == 1`
   example_4 =
      { start = "L1",
        order = { "L1", "L4", "L6", "L7", "L5" },
        blocks =
           { L1 = { label = "L1",
                    bindings = {},
                    control = { "if", { ">=", "len", 34 }, "L4", "L5" } },
             L4 = { label = "L4",
                    bindings = {},
                    control = { "if", { "=", { "[]", 12, 2 }, 8 }, "L6", "L7" } },
             L6 = { label = "L6",
                    bindings = {},
		    control = { "return",
                                { "=", { "+", { "+", { "[]", 15, 1 }, { "[]", 16, 1 } },
                                         { "[]", 17, 1 } }, 1 } } },
             L7 = { label = "L7",
                    bindings = {},
                    control = { "return", { "false" } } },
             L5 = { label = "L5",
                    bindings = {},
                    control = { "return", { "false" } } } } }

   local function test(ssa, pkt, alloc)
      -- Compile and then call native function on the given packet
      local instr = sel.select(ssa)

      if not alloc then
         alloc = ra.allocate(instr)
      end

      local f = compile(instr, alloc)
      return f(pkt.packet, pkt.len)
   end

   local savefile = require("pf.savefile")
   arp_pkts = savefile.load_packets("../tests/data/arp.pcap")
   v4_pkts = savefile.load_packets("../tests/data/v4.pcap")
   v6_pkts = savefile.load_packets("../tests/data/v6.pcap")

   -- not an arp packet
   local alloc_1 = { len = 6, r1 = 0, callee_saves = {} }
   assert(not test(example_1, arp_pkts[1], alloc_1))
   assert(not test(example_1, arp_pkts[2], alloc_1))
   assert(not test(example_1, arp_pkts[1]))
   assert(not test(example_1, arp_pkts[2]))
   -- yay arp
   assert(test(example_2, arp_pkts[1], alloc_1))
   assert(test(example_2, arp_pkts[2], alloc_1))
   assert(test(example_2, arp_pkts[1]))
   assert(test(example_2, arp_pkts[2]))

   assert(not test(example_3,
                   arp_pkts[1]))
   assert(test(example_3,
               -- this one is a TCP packet
               v4_pkts[1]))
   assert(test(example_3,
               -- this one is also a TCP packet
               v6_pkts[16]))

   test(example_4, arp_pkts[1])

   -- test starting from parsing all the way to codegen
   local parse = require('pf.parse').parse
   local expand = require('pf.expand').expand
   local optimize = require('pf.optimize').optimize
   local convert_anf = require('pf.anf').convert_anf
   local convert_ssa = require('pf.ssa').convert_ssa

   local function test(expr, pkt)
      local ssa = convert_ssa(convert_anf(optimize(expand(parse(expr), "EN10MB"))))
      local instr = sel.select(ssa)
      local alloc = ra.allocate(instr)
      local f = compile(instr, alloc)
      return f(pkt.packet, pkt.len)
   end

   assert(not test("tcp port 3372", arp_pkts[1]))
   assert(test("tcp port 3372", v4_pkts[1]))
   assert(test("tcp port 3372", v4_pkts[2]))
   assert(not test("tcp port 3372", v4_pkts[13]))
   assert(not test("tcp port 3372", v4_pkts[18]))
   assert(not test("tcp port 3372", v4_pkts[24]))

   assert(not test("portrange 0-6000", arp_pkts[1]))
   assert(test("portrange 0-6000", v4_pkts[1]))
   assert(test("portrange 0-80", v4_pkts[1]))
   assert(not test("portrange 100-2000", v4_pkts[1]))
   assert(test("portrange 0-6000", v4_pkts[2]))
   assert(test("portrange 0-6000", v4_pkts[13]))
   assert(not test("portrange 0-30", v4_pkts[13]))
   assert(not test("portrange 4000-9000", v4_pkts[13]))
   assert(test("portrange 0-6000", v4_pkts[18]))
   assert(test("portrange 0-6000", v4_pkts[24]))

   assert(test("net 145.254.160.237", v4_pkts[1]))
   assert(not test("net 178.79.150.233", v4_pkts[1]))
   assert(test("net 145.254.160.0/24", v4_pkts[1]))
   assert(not test("net 178.79.150.0/24", v4_pkts[1]))

   print("OK")
end
